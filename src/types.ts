import { Converter } from "./converter/converter.js";
import { BmarkEvent } from "./helpers/event.js";
export interface EventListener {
  /**
   * @param evtName - The event name.
   * @param text - The current convert value.
   * @param converter - The converter instance.
   * @param options - The converter options.
   * @param globals - A global parsed data of the current conversion.
   * @returns Can be returned string value to change the current convert value (`text`).
   * @example
   * Change by returns string value.
   * ```ts
   * let listener: EventListener = (evtName, text, converter, options, globals) => doSome(text);
   * ```
   */
  (
    evtName: string,
    text: string,
    converter: Converter,
    options: BmarkOptions,
    globals: ConverterGlobals //TODO
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  ): void | string;
}

export type Event = "lang" | "output" | "listener";
export interface Extension {
  /**
   * Property defines the nature of said sub-extensions and can assume 2 values:
   *
   * * `lang`  - Language extensions add new markdown syntax to showdown.
   * * `output` - Output extensions (or modifiers) alter the HTML output generated by showdown.
   * * `listener` - Listener extensions for listening to a conversion event.
   */
  type: string;

  /**
   * Event listeners functions that called on the conversion, when the `event` occurs.
   */
  listeners?: { [event: string]: EventListener } | undefined;
}
export interface RegexReplaceExtension extends Extension {
  /**
   * Should be either a string or a RegExp object.
   *
   * Keep in mind that, if a string is used, it will automatically be given a g modifier,
   * that is, it is assumed to be a global replacement.
   */
  regex?: string | RegExp | undefined;

  /**
   * Can be either a string or a function. If replace is a string,
   * it can use the $1 syntax for group substitution,
   * exactly as if it were making use of string.replace (internally it does this actually).
   */
  replace?: any; // string | Replace
}
/**
 * If you'd just like to do everything yourself,you can specify a filter property.
 * The filter property should be a function that acts as a callback.
 *
 * @example
 * ```ts
 * let myExt: ShowdownExtension = {
 *   type: 'lang',
 *   filter: (text: string, converter: Converter) => text.replace('#', '*')
 * };
 * ```
 */
export interface FilterExtension extends Extension {
  filter?:
    | ((
        text: string,
        converter: Converter,
        options?: ConverterOptions
      ) => string)
    | undefined;
}
/**
 * Defines a plugin/extension
 * Each single extension can be one of two types:
 *
 * + Language Extension -- Language extensions are ones that that add new markdown syntax to showdown. For example, say you wanted ^^youtube http://www.youtube.com/watch?v=oHg5SJYRHA0 to automatically render as an embedded YouTube video, that would be a language extension.
 * + Output Modifiers -- After showdown has run, and generated HTML, an output modifier would change that HTML. For example, say you wanted to change <div class="header"> to be <header>, that would be an output modifier.
 * + Listener Extension -- Listener extensions for listen to conversion events.
 *
 * Each extension can provide two combinations of interfaces for showdown.
 *
 * @example
 * ```ts
 * let myext: ShowdownExtension = {
 *   type: 'output',
 *   filter(text, converter, options) {
 *      // ... do stuff to text ...
 *      return text;
 *   },
 *   listeners: {
 *      ['lists.after'](evtName, text, converter, options, globals){
 *          // ... do stuff to text ...
 *          return text;
 *      },
 *      // ...
 *   }
 * };
 * ```
 */
export interface BmarkExtension
  extends RegexReplaceExtension,
    FilterExtension {}

export interface BmarkExtensions {
  [name: string]: BmarkExtension[];
}
type Bext =
  | (() => BmarkExtension[] | BmarkExtension)
  | BmarkExtension[]
  | BmarkExtension
  | string;
export type ConverterExtensionsType = Array<Bext>;
type DFOpts = {
  defaultValue: boolean | number | string | [];
  describe: string;
  type: string;
};
type DefOpts = {
  [key: string]: DFOpts;
};
type HeaderID = 1 | 2 | 3 | 4 | 5 | 6;
export type OptionsValue =
  | string
  | number
  | undefined
  | HeaderID
  | boolean
  | ConverterExtensionsType;

export interface BmarkOptions {
  [key: string]: OptionsValue;
  omitExtraWLInCodeBlocks?: boolean;
  noHeaderId?: boolean;
  prefixHeaderId?: boolean;
  rawPrefixHeaderId?: boolean;
  ghCompatibleHeaderId?: boolean;
  rawHeaderId?: boolean;
  headerLevelStart?: HeaderID;
  parseImgDimensions?: boolean;
  simplifiedAutoLink?: boolean;
  literalMidWordUnderscores?: boolean;
  literalMidWordAsterisks?: boolean;
  strikethrough?: boolean;
  tables?: boolean;
  tablesHeaderId?: boolean;
  ghCodeBlocks?: boolean;
  tasklists?: boolean;
  smoothLivePreview?: boolean;
  smartIndentationFix?: boolean;
  disableForced4SpacesIndentedSublists?: boolean;
  simpleLineBreaks?: boolean;
  requireSpaceBeforeHeadingText?: boolean;
  ghMentions?: boolean;
  ghMentionsLink?: string;
  encodeEmails?: boolean;
  openLinksInNewWindow?: boolean;
  backslashEscapesHTMLTags?: boolean;
  emoji?: boolean;
  underline?: boolean;
  ellipsis?: boolean;
  completeHTMLDocument?: boolean;
  metadata?: boolean;
  splitAdjacentBlockquotes?: boolean;
  moreStyling?: boolean;
  relativePathBaseUrl?: boolean;
}
export interface ConverterOptions extends BmarkOptions {
  extensions?: ConverterExtensionsType;
}

export type FlavorOptions = {
  github: Partial<BmarkOptions>;
  original: Partial<BmarkOptions>;
  ghost: Partial<BmarkOptions>;
  vanilla: BmarkOptions;
  allTrue: BmarkOptions;
};
export type Flavor = "github" | "original" | "ghost" | "vanilla" | "allTrue";
export interface ConverterGlobals {
  converter?: Converter;
  gDimensions?:
    | {
        width?: number | undefined;
        height?: number | undefined;
      }
    | undefined;
  gHtmlBlocks?: string[] | undefined;
  gHtmlMdBlocks?: string[] | undefined;
  gHtmlSpans?: string[] | undefined;
  gListLevel?: number | undefined;
  gTitles?: { [key: string]: string } | undefined;
  gUrls?: { [key: string]: string } | undefined;
  ghCodeBlocks?:
    | Array<{ codeblock?: string | undefined; text?: string | undefined }>
    | undefined;
  hashLinkCounts?: { [key: string]: number } | undefined;
  langExtensions?: BmarkExtension[] | undefined;
  metadata?:
    | {
        parsed?: { [key: string]: string } | undefined;
        raw?: string | undefined;
        format?: string | undefined;
      }
    | undefined;
  outputModifiers?: BmarkExtension[] | undefined;
}

/**
 * Type subParser.
 */
export type SubParser = (...args: any[]) => string;

export type Parsers = {
  [name: string]: SubParser;
};

// Helper

export type EventArgs = {
  name?: string;
  text?: string;
  params?: {
    regexp?: RegExp | null;
    matches?: Object | {};
    options?: ConverterOptions | {};
    converter?: Converter | null;
    globals?: ConverterGlobals | {};
    parsedText?: string | string[] | null;
    text?: string;
  };
};

export interface EventTypes {
  _stopExecution: boolean;
  parsedText: string | string[] | null;
  getName: () => string | undefined;
  getEventName: () => string | undefined;
  getRegexp: () => RegExp | null | undefined;
  getOptions: () => {} | Object | undefined;
  getConverter: () => any;
  getGlobals: () => {} | ConverterGlobals | undefined;
  getCapturedText: () => string | undefined;
  preventDefault: (bool: boolean) => void;
  getText: () => string | undefined;
  setText: (newText: string) => void;
  getMatches: () => {} | Object | undefined;
  setMatches: (newMatches: Object | {}) => void;
}
export interface HelpersTypes {
  isString: (test: any) => test is string;
  isFunction: (test: any) => boolean;
  isArray: (test: any) => boolean;
  isUndefined: (test: any) => test is undefined;
  forEach(obj: any, callback: Function): void;
  stdExtName(s: string): string;
  escapeCharactersCallback(wholeMatch: any, m1: any): string;
  escapeCharacters(
    text: string,
    charsToEscape: string,
    afterBackslash: boolean
  ): string | void | any;
  matchRecursiveRegExp(str: any, left: any, right: any, flags: any): any[][];
  replaceRecursiveRegExp(
    str: string,
    replacement: string | Function,
    left: string,
    right: string,
    flags: string
  ): string;
  regexIndexOf(str: string, regex: RegExp, fromIndex?: any): number;
  splitAtIndex(str: string, index: number): [string, string];
  encodeEmailAddress(mail: string): string;
  repeat(str: string, count: number): string;
  padEnd(
    str: string,
    targetLength: number,
    padString?: string | undefined
  ): string;
  unescapeHTMLEntities(txt: any): string;
  _hashHTMLSpan(html: any, globals: any): string;
  applyBaseUrl(baseUrl: string, url: string): string;
  isAbsolutePath(path: string): boolean;
  regexes: {
    asteriskDashTildeAndColon: RegExp;
    asteriskDashAndTilde: RegExp;
  };
  Event: typeof BmarkEvent;
  emoji: _Emoji;
}
export type _Emoji = {
  [key: string]: string;
};
