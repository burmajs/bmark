import { type BmarkOptions, type ConverterOptions } from "../lib/options.js";
import { type ConverterGlobals } from "../lib/globals.js";
import { Converter } from "../converter/converter.js";
export interface EventListener {
  /**
   * @param evtName - The event name.
   * @param text - The current convert value.
   * @param converter - The converter instance.
   * @param options - The converter options.
   * @param globals - A global parsed data of the current conversion.
   * @returns Can be returned string value to change the current convert value (`text`).
   * @example
   * Change by returns string value.
   * ```ts
   * let listener: EventListener = (evtName, text, converter, options, globals) => doSome(text);
   * ```
   */
  (
    evtName: string,
    text: string,
    converter: Converter,
    options: BmarkOptions,
    globals: ConverterGlobals //TODO
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  ): void | string;
}

export type Event = "lang" | "output" | "listener";
export interface Extension {
  /**
   * Property defines the nature of said sub-extensions and can assume 2 values:
   *
   * * `lang`  - Language extensions add new markdown syntax to showdown.
   * * `output` - Output extensions (or modifiers) alter the HTML output generated by showdown.
   * * `listener` - Listener extensions for listening to a conversion event.
   */
  type: string;

  /**
   * Event listeners functions that called on the conversion, when the `event` occurs.
   */
  listeners?: { [event: string]: EventListener } | undefined;
}
export interface RegexReplaceExtension extends Extension {
  /**
   * Should be either a string or a RegExp object.
   *
   * Keep in mind that, if a string is used, it will automatically be given a g modifier,
   * that is, it is assumed to be a global replacement.
   */
  regex?: string | RegExp | undefined;

  /**
   * Can be either a string or a function. If replace is a string,
   * it can use the $1 syntax for group substitution,
   * exactly as if it were making use of string.replace (internally it does this actually).
   */
  replace?: any; // string | Replace
}
/**
 * If you'd just like to do everything yourself,you can specify a filter property.
 * The filter property should be a function that acts as a callback.
 *
 * @example
 * ```ts
 * let myExt: ShowdownExtension = {
 *   type: 'lang',
 *   filter: (text: string, converter: Converter) => text.replace('#', '*')
 * };
 * ```
 */
export interface FilterExtension extends Extension {
  filter?:
    | ((
        text: string,
        converter: Converter,
        options?: ConverterOptions
      ) => string)
    | undefined;
}
/**
 * Defines a plugin/extension
 * Each single extension can be one of two types:
 *
 * + Language Extension -- Language extensions are ones that that add new markdown syntax to showdown. For example, say you wanted ^^youtube http://www.youtube.com/watch?v=oHg5SJYRHA0 to automatically render as an embedded YouTube video, that would be a language extension.
 * + Output Modifiers -- After showdown has run, and generated HTML, an output modifier would change that HTML. For example, say you wanted to change <div class="header"> to be <header>, that would be an output modifier.
 * + Listener Extension -- Listener extensions for listen to conversion events.
 *
 * Each extension can provide two combinations of interfaces for showdown.
 *
 * @example
 * ```ts
 * let myext: ShowdownExtension = {
 *   type: 'output',
 *   filter(text, converter, options) {
 *      // ... do stuff to text ...
 *      return text;
 *   },
 *   listeners: {
 *      ['lists.after'](evtName, text, converter, options, globals){
 *          // ... do stuff to text ...
 *          return text;
 *      },
 *      // ...
 *   }
 * };
 * ```
 */
export interface BmarkExtension
  extends RegexReplaceExtension,
    FilterExtension {}

export interface BmarkExtensions {
  [name: string]: BmarkExtension[];
}
